diff --git a/src/api/CMakeLists.txt b/src/api/CMakeLists.txt
index 8e796168..a58ee4ba 100644
--- a/src/api/CMakeLists.txt
+++ b/src/api/CMakeLists.txt
@@ -64,6 +64,7 @@ z3_add_component(api
     api_stats.cpp
     api_tactic.cpp
     z3_replayer.cpp
+    api_special_relations.cpp
     ${full_path_generated_files}
   COMPONENT_DEPENDENCIES
     interp
diff --git a/src/api/api_ast.cpp b/src/api/api_ast.cpp
index 7342b3c4..677bfcd4 100644
--- a/src/api/api_ast.cpp
+++ b/src/api/api_ast.cpp
@@ -1239,6 +1239,19 @@ extern "C" {
             }
         }
 
+        //BEGIN: ASHU
+        if (mk_c(c)->get_special_relations_fid() == _d->get_family_id()) {
+            switch(_d->get_decl_kind()) {
+            case OP_SPECIAL_RELATION_LO : return Z3_OP_SPECIAL_RELATION_LO;
+            case OP_SPECIAL_RELATION_PO : return Z3_OP_SPECIAL_RELATION_PO;
+            case OP_SPECIAL_RELATION_PO_AO : return Z3_OP_SPECIAL_RELATION_PO_AO;
+            case OP_SPECIAL_RELATION_PLO: return Z3_OP_SPECIAL_RELATION_PLO;
+            case OP_SPECIAL_RELATION_TO : return Z3_OP_SPECIAL_RELATION_TO;
+            default: UNREACHABLE();
+            }
+        }
+        //END: ASHU
+
         return Z3_OP_UNINTERPRETED;
         Z3_CATCH_RETURN(Z3_OP_UNINTERPRETED);
     }
diff --git a/src/api/api_context.cpp b/src/api/api_context.cpp
index bcd3c60f..e163d407 100644
--- a/src/api/api_context.cpp
+++ b/src/api/api_context.cpp
@@ -81,6 +81,7 @@ namespace api {
         m_fpa_util(m()),
         m_dtutil(m()),
         m_sutil(m()),
+        m_sr_util(m()),  //ASHU: addition
         m_last_result(m()),
         m_ast_trail(m()),
         m_pmanager(m_limit) {
@@ -104,6 +105,7 @@ namespace api {
         m_datalog_fid = m().mk_family_id("datalog_relation");
         m_fpa_fid   = m().mk_family_id("fpa");
         m_seq_fid   = m().mk_family_id("seq");
+        m_sr_fid    = m().mk_family_id("special_relations"); //ASHU: addition
         m_dt_plugin = static_cast<datatype_decl_plugin*>(m().get_plugin(m_dt_fid));
     
         install_tactics(*this);
diff --git a/src/api/api_context.h b/src/api/api_context.h
index 4685fd04..f4e13c10 100644
--- a/src/api/api_context.h
+++ b/src/api/api_context.h
@@ -35,6 +35,7 @@ Revision History:
 #include"tactic_manager.h"
 #include"context_params.h"
 #include"api_polynomial.h"
+#include"special_relations_decl_plugin.h" //ASHU: addition
 #include"hashtable.h"
 
 namespace smtlib {
@@ -61,6 +62,7 @@ namespace api {
         fpa_util                   m_fpa_util;
         datatype_util              m_dtutil;
         seq_util                   m_sutil;
+        special_relations_util     m_sr_util; //ASHU: addition
 
         // Support for old solver API
         smt_params                 m_fparams;
@@ -82,6 +84,7 @@ namespace api {
         family_id                  m_pb_fid;
         family_id                  m_fpa_fid;
         family_id                  m_seq_fid;
+        family_id                  m_sr_fid; //ASHU: addition
         datatype_decl_plugin *     m_dt_plugin;
         
         std::string                m_string_buffer; // temporary buffer used to cache strings sent to the "external" world.
@@ -126,6 +129,7 @@ namespace api {
         fpa_util & fpautil() { return m_fpa_util; }
         datatype_util& dtutil() { return m_dtutil; }
         seq_util& sutil() { return m_sutil; }
+        special_relations_util& sr_util() { return m_sr_util; } //ASHU: added
         family_id get_basic_fid() const { return m_basic_fid; }
         family_id get_array_fid() const { return m_array_fid; }
         family_id get_arith_fid() const { return m_arith_fid; }
@@ -135,6 +139,7 @@ namespace api {
         family_id get_pb_fid() const { return m_pb_fid; }
         family_id get_fpa_fid() const { return m_fpa_fid; }
         family_id get_seq_fid() const { return m_seq_fid; }
+        family_id get_special_relations_fid() const { return m_sr_fid; } //ASHU: added
         datatype_decl_plugin * get_dt_plugin() const { return m_dt_plugin; }
 
         Z3_error_code get_error_code() const { return m_error_code; }
diff --git a/src/api/api_solver.cpp b/src/api/api_solver.cpp
index 6dc41efb..d9200f78 100644
--- a/src/api/api_solver.cpp
+++ b/src/api/api_solver.cpp
@@ -34,6 +34,13 @@ Revision History:
 #include"smt_implied_equalities.h"
 #include"smt_logics.h"
 
+//BEGIN: ASHU
+Z3_ast_vector_ref* asserted_linear_constr = NULL;
+ast_ref_vector* asserted_linear_constr_vector;
+Z3_ast_vector_ref* asserted_po_constr = NULL;
+ast_ref_vector* asserted_po_constr_vector;
+//END: ASHU
+
 extern "C" {
 
     static void init_solver_core(Z3_context c, Z3_solver _s) {
@@ -48,6 +55,18 @@ extern "C" {
         context_params::collect_solver_param_descrs(r);
         p.validate(r);
         s->m_solver->updt_params(p);
+        //BEGIN: ASHU
+        if (asserted_linear_constr == NULL) {
+          asserted_linear_constr = alloc(Z3_ast_vector_ref, *mk_c(c), mk_c(c)->m());
+          asserted_linear_constr_vector = &(asserted_linear_constr->m_ast_vector);
+          asserted_linear_constr->inc_ref();
+        }
+        if (asserted_po_constr == NULL) {
+          asserted_po_constr = alloc(Z3_ast_vector_ref, *mk_c(c), mk_c(c)->m());
+          asserted_po_constr_vector = &(asserted_po_constr->m_ast_vector);
+          asserted_po_constr->inc_ref();
+        }
+        //END: ASHU
     }
 
     static void init_solver(Z3_context c, Z3_solver s) {
@@ -422,6 +441,25 @@ extern "C" {
         Z3_CATCH_RETURN(Z3_L_UNDEF);
     }
 
+  //BEGIN: ASHU
+  //extern smt::smt_kernel* proper_kernel;
+
+  Z3_ast_vector Z3_API Z3_collect_last_asserted_linear_constr(void) {
+    return of_ast_vector(asserted_linear_constr);
+  }
+
+  void Z3_API Z3_delete_last_asserted_linear_constr(void) {
+    if (asserted_linear_constr != NULL)
+      asserted_linear_constr->dec_ref();
+  }
+  Z3_ast_vector Z3_API Z3_collect_last_asserted_po_constr(void) {
+    return of_ast_vector(asserted_po_constr);
+  }
+
+  void Z3_API Z3_delete_last_asserted_po_constr(void) {
+    if (asserted_po_constr != NULL)
+      asserted_po_constr->dec_ref();
+  }
     Z3_lbool Z3_API Z3_solver_get_consequences(Z3_context c, 
                                         Z3_solver s,
                                         Z3_ast_vector assumptions,
@@ -477,4 +515,5 @@ extern "C" {
         Z3_CATCH_RETURN(Z3_L_UNDEF);        
     }
 
+
 };
diff --git a/src/api/c++/z3++.h b/src/api/c++/z3++.h
index 9d998252..cf4dcf14 100644
--- a/src/api/c++/z3++.h
+++ b/src/api/c++/z3++.h
@@ -161,8 +161,9 @@ namespace z3 {
         struct interpolation {};
         context() { config c; init(c); }
         context(config & c) { init(c); }
-        context(config & c, interpolation) { init_interp(c); }
-        ~context() { Z3_del_context(m_ctx); }
+
+	context(config & c, interpolation) { init_interp(c); }
+      ~context() { Z3_delete_last_asserted_linear_constr(); Z3_delete_last_asserted_po_constr(); Z3_del_context(m_ctx); } // ASHU
         operator Z3_context() const { return m_ctx; }
 
         /**
@@ -275,6 +276,9 @@ namespace z3 {
 
         expr constant(symbol const & name, sort const & s);
         expr constant(char const * name, sort const & s);
+        //BEGIN: ASHU
+        expr fresh_constant(char const * name, sort const & s);// ASHU
+       //END: ASHU
         expr bool_const(char const * name);
         expr int_const(char const * name);
         expr real_const(char const * name);
@@ -306,6 +310,11 @@ namespace z3 {
 
         expr num_val(int n, sort const & s);
 
+      //BEGIN: ASHU
+      expr_vector collect_last_asserted_linear_constr(void);
+      expr_vector collect_last_asserted_po_constr(void);
+      //END: ASHU
+
         /**
            \brief parsing
          */
@@ -587,6 +596,13 @@ namespace z3 {
         expr(expr const & n):ast(n) {}
         expr & operator=(expr const & n) { return static_cast<expr&>(ast::operator=(n)); }
 
+      //BEGIN: ASHU
+        bool get_bool() const {
+          Z3_lbool b = Z3_get_bool_value(*m_ctx, m_ast);
+          assert(b!=Z3_L_UNDEF);
+          return b==Z3_L_TRUE;
+        }
+      //END: ASHU
         /**
            \brief Return the sort of this expression.
         */
@@ -2018,6 +2034,14 @@ namespace z3 {
         }
     public:
         tactic(context & c, char const * name):object(c) { Z3_tactic r = Z3_mk_tactic(c, name); check_error(); init(r); }
+        tactic(tactic const & tactic, params const & params):object(tactic) {
+          Z3_param_descrs pd = Z3_tactic_get_param_descrs(ctx(), tactic);
+          Z3_param_descrs_inc_ref(ctx(), pd);
+          Z3_params_validate(ctx(), params, pd);
+          check_error();
+          Z3_param_descrs_dec_ref(ctx(), pd);
+          Z3_tactic r = Z3_tactic_using_params(tactic.ctx(), tactic, params); check_error(); init(r);
+        }
         tactic(context & c, Z3_tactic s):object(c) { init(s); }
         tactic(tactic const & s):object(s) { init(s.m_tactic); }
         ~tactic() { Z3_tactic_dec_ref(ctx(), m_tactic); }
@@ -2403,6 +2427,13 @@ namespace z3 {
         check_error();
         return expr(*this, r);
     }
+  //BEGIN: ASHU
+    inline expr context::fresh_constant(char const * name, sort const & s) {
+      Z3_ast r = Z3_mk_fresh_const(m_ctx, name, s);
+      check_error();
+      return expr(*this, r);
+    }
+  //END: ASHU
     inline expr context::constant(char const * name, sort const & s) { return constant(str_symbol(name), s); }
     inline expr context::bool_const(char const * name) { return constant(name, bool_sort()); }
     inline expr context::int_const(char const * name) { return constant(name, int_sort()); }
@@ -2696,6 +2727,40 @@ namespace z3 {
 
 
 
+    inline expr sr_lo(expr const& a, expr const& b) {
+        check_context(a, b);
+        Z3_ast r = Z3_mk_sr_lo(a.ctx(), a, b);
+        a.check_error();
+        return expr(a.ctx(), r);
+    }
+
+    inline expr sr_po(expr const& a, expr const& b) {
+        check_context(a, b);
+        Z3_ast r = Z3_mk_sr_po(a.ctx(), a, b);
+        a.check_error();
+        return expr(a.ctx(), r);
+    }
+
+    inline expr sr_po_ao(expr const& a, expr const& b) {
+        check_context(a, b);
+        Z3_ast r = Z3_mk_sr_po_ao(a.ctx(), a, b);
+        a.check_error();
+        return expr(a.ctx(), r);
+    }
+
+    inline expr sr_plo(expr const& a, expr const& b) {
+        check_context(a, b);
+        Z3_ast r = Z3_mk_sr_plo(a.ctx(), a, b);
+        a.check_error();
+        return expr(a.ctx(), r);
+    }
+
+    inline expr sr_to(expr const& a, expr const& b) {
+        check_context(a, b);
+        Z3_ast r = Z3_mk_sr_to(a.ctx(), a, b);
+        a.check_error();
+        return expr(a.ctx(), r);
+    }
 
     inline expr interpolant(expr const& a) {
         return expr(a.ctx(), Z3_mk_interpolant(a.ctx(), a));
@@ -2790,7 +2855,29 @@ namespace z3 {
         return expr(ctx(), r);
     }
 
-
+  //BEGIN: ASHU
+    inline expr_vector context::collect_last_asserted_linear_constr(void) {
+      Z3_ast_vector asserted1 = Z3_collect_last_asserted_linear_constr();
+      z3::expr_vector asserted = expr_vector(*this, asserted1);
+      return asserted;
+    }
+
+    inline expr_vector context::collect_last_asserted_po_constr(void) {
+      Z3_ast_vector asserted1 = Z3_collect_last_asserted_po_constr();
+      z3::expr_vector asserted = expr_vector(*this, asserted1);
+      return asserted;
+    }
+    // inline expr distinct(expr_vector const& args) {
+    //   array<Z3_ast> _args(args.size());
+    //   for (unsigned i = 0; i < args.size(); i++) {
+    //     check_context(args.ctx(), args[i]);
+    //     _args[i] = args[i];
+    //   }
+    //   Z3_ast r = Z3_mk_distinct(args.ctx(), args.size(), _args.ptr());
+    //   args.ctx().check_error();
+    //   return expr(args.ctx(), r);
+    // }
+  //END: ASHU
 
 }
 
diff --git a/src/api/z3_api.h b/src/api/z3_api.h
index 63f1d15f..1ce86d36 100644
--- a/src/api/z3_api.h
+++ b/src/api/z3_api.h
@@ -1239,6 +1239,14 @@ typedef enum {
     Z3_OP_FPA_MIN_I,
     Z3_OP_FPA_MAX_I,
 
+    //BEGIN: ASHU
+    Z3_OP_SPECIAL_RELATION_LO,
+    Z3_OP_SPECIAL_RELATION_PO,
+    Z3_OP_SPECIAL_RELATION_PO_AO,
+    Z3_OP_SPECIAL_RELATION_PLO,
+    Z3_OP_SPECIAL_RELATION_TO,
+    //END: ASHU
+
     Z3_OP_INTERNAL,
 
     Z3_OP_UNINTERPRETED
@@ -3455,6 +3463,52 @@ extern "C" {
     /*@}*/
 
 
+    /**
+       \brief declare \c a and \c b are in linear order.
+
+       \pre a and b are of same type.
+
+       def_API('Z3_mk_sr_lo' ,AST ,(_in(CONTEXT), _in(AST), _in(AST)))
+     */
+    Z3_ast Z3_API Z3_mk_sr_lo(Z3_context c, Z3_ast a, Z3_ast b);
+
+    /**
+       \brief declare \c a and \c b are in partial order.
+
+       \pre a and b are of same type.
+
+       def_API('Z3_mk_sr_po' ,AST ,(_in(CONTEXT), _in(AST), _in(AST)))
+     */
+    Z3_ast Z3_API Z3_mk_sr_po(Z3_context c, Z3_ast a, Z3_ast b);
+
+    /**
+       \brief declare \c a and \c b are already partial ordered.
+
+       \pre a and b are of same type.
+
+       def_API('Z3_mk_sr_po_ao' ,AST ,(_in(CONTEXT), _in(AST), _in(AST)))
+     */
+    Z3_ast Z3_API Z3_mk_sr_po_ao(Z3_context c, Z3_ast a, Z3_ast b);
+
+    /**
+       \brief declare \c a and \c b are in piecewise linear order.
+
+       \pre a and b are of same type.
+
+       def_API('Z3_mk_sr_plo' ,AST ,(_in(CONTEXT), _in(AST), _in(AST)))
+     */
+    Z3_ast Z3_API Z3_mk_sr_plo(Z3_context c, Z3_ast a, Z3_ast b);
+
+    /**
+       \brief declare \c a and \c b are in total order.
+
+       \pre a and b are of same type.
+
+       def_API('Z3_mk_sr_to' ,AST ,(_in(CONTEXT), _in(AST), _in(AST)))
+     */
+    Z3_ast Z3_API Z3_mk_sr_to(Z3_context c, Z3_ast a, Z3_ast b);
+
+
     /** @name Quantifiers */
     /*@{*/
     /**
@@ -6203,6 +6257,13 @@ extern "C" {
 
     /*@}*/
 
+  //BEGIN: ASHU
+  Z3_ast_vector Z3_API Z3_collect_last_asserted_linear_constr(void);
+  void Z3_API Z3_delete_last_asserted_linear_constr(void);
+  Z3_ast_vector Z3_API Z3_collect_last_asserted_po_constr(void);
+  void Z3_API Z3_delete_last_asserted_po_constr(void);
+  //END: ASHU
+
 #ifdef __cplusplus
 }
 #endif // __cplusplus
diff --git a/src/ast/CMakeLists.txt b/src/ast/CMakeLists.txt
index de0e4bda..0483477d 100644
--- a/src/ast/CMakeLists.txt
+++ b/src/ast/CMakeLists.txt
@@ -40,6 +40,7 @@ z3_add_component(ast
     static_features.cpp
     used_vars.cpp
     well_sorted.cpp
+    special_relations_decl_plugin.cpp
   COMPONENT_DEPENDENCIES
     polynomial
     util # Unnecessary? polynomial already depends on util
diff --git a/src/ast/reg_decl_plugins.cpp b/src/ast/reg_decl_plugins.cpp
index b4ff63ed..e9142026 100644
--- a/src/ast/reg_decl_plugins.cpp
+++ b/src/ast/reg_decl_plugins.cpp
@@ -26,6 +26,7 @@ Revision History:
 #include"seq_decl_plugin.h"
 #include"pb_decl_plugin.h"
 #include"fpa_decl_plugin.h"
+#include"special_relations_decl_plugin.h" //ASHU: added
 
 void reg_decl_plugins(ast_manager & m) {
     if (!m.get_plugin(m.mk_family_id(symbol("arith")))) {
@@ -52,4 +53,7 @@ void reg_decl_plugins(ast_manager & m) {
     if (!m.get_plugin(m.mk_family_id(symbol("pb")))) {
         m.register_plugin(symbol("pb"), alloc(pb_decl_plugin));
     }
+    if (!m.get_plugin(m.mk_family_id(symbol("special_relations")))) { //ASHU: added
+        m.register_plugin(symbol("special_relations"), alloc(special_relations_decl_plugin));
+    }
 }
diff --git a/src/cmd_context/cmd_context.cpp b/src/cmd_context/cmd_context.cpp
index af16f579..2ad12ed9 100644
--- a/src/cmd_context/cmd_context.cpp
+++ b/src/cmd_context/cmd_context.cpp
@@ -27,6 +27,7 @@ Notes:
 #include"seq_decl_plugin.h"
 #include"pb_decl_plugin.h"
 #include"fpa_decl_plugin.h"
+#include"special_relations_decl_plugin.h"
 #include"ast_pp.h"
 #include"var_subst.h"
 #include"pp.h"
@@ -557,6 +558,7 @@ void cmd_context::init_manager_core(bool new_manager) {
         register_plugin(symbol("pb"),       alloc(pb_decl_plugin), logic_has_pb());
         register_plugin(symbol("fpa"),      alloc(fpa_decl_plugin), logic_has_fpa());
         register_plugin(symbol("datalog_relation"), alloc(datalog::dl_decl_plugin), !has_logic());
+        register_plugin(symbol("special_relations"), alloc(special_relations_decl_plugin), !has_logic());
     }
     else {
         // the manager was created by an external module
diff --git a/src/smt/CMakeLists.txt b/src/smt/CMakeLists.txt
index 41890dd0..9905e489 100644
--- a/src/smt/CMakeLists.txt
+++ b/src/smt/CMakeLists.txt
@@ -64,6 +64,8 @@ z3_add_component(smt
     theory_wmaxsat.cpp
     uses_theory.cpp
     watch_list.cpp
+    smt_model_reporter.cpp
+    theory_special_relations.cpp
   COMPONENT_DEPENDENCIES
     bit_blaster
     cmd_context
diff --git a/src/smt/diff_logic.h b/src/smt/diff_logic.h
index f55945ce..b17a6ba0 100644
--- a/src/smt/diff_logic.h
+++ b/src/smt/diff_logic.h
@@ -26,6 +26,8 @@ Revision History:
 #include"warning.h"
 #include"uint_set.h"
 #include<deque>
+#include<queue>
+#include<unordered_map>
 
 typedef int dl_var;
 
@@ -50,7 +52,7 @@ class dl_edge {
     dl_var      m_source;
     dl_var      m_target;
     numeral     m_weight;
-    unsigned    m_timestamp;  
+    unsigned    m_timestamp;
     explanation m_explanation;
     bool        m_enabled;
 public:
@@ -59,7 +61,7 @@ public:
         m_source(s),
         m_target(t),
         m_weight(w),
-        m_timestamp(ts), 
+        m_timestamp(ts),
         m_explanation(ex),
         m_enabled(false) {
     }
@@ -79,8 +81,8 @@ public:
     const explanation & get_explanation() const {
         return m_explanation;
     }
-    
-    unsigned get_timestamp() const { 
+
+    unsigned get_timestamp() const {
         return m_timestamp;
     }
 
@@ -149,7 +151,7 @@ class dl_graph {
     typedef vector<numeral> assignment;
     typedef dl_edge<Ext>    edge;
     typedef vector<edge>    edges;
-    
+
     class assignment_trail {
         dl_var  m_var;
         numeral m_old_value;
@@ -158,7 +160,7 @@ class dl_graph {
             m_var(v),
             m_old_value(val) {
         }
-        
+
         dl_var get_var() const {
             return m_var;
         }
@@ -173,10 +175,10 @@ class dl_graph {
     assignment              m_assignment;       // per var
     assignment_stack        m_assignment_stack; // temporary stack for restoring the assignment
     edges                   m_edges;
-    
+
     typedef int_vector      edge_id_vector;
     typedef int_vector      dl_var_vector;
-    
+
     vector<edge_id_vector>  m_out_edges;  // per var
     vector<edge_id_vector>  m_in_edges;   // per var
 
@@ -197,7 +199,7 @@ class dl_graph {
     vector<numeral>         m_gamma;    // per var
     svector<char>           m_mark;     // per var
     edge_id_vector          m_parent;   // per var
-    dl_var_vector           m_visited; 
+    dl_var_vector           m_visited;
     typedef heap<dl_var_lt<Ext> > var_heap;
     var_heap                m_heap;
 
@@ -208,7 +210,7 @@ class dl_graph {
     // SCC for cheap equality propagation --
     svector<char>           m_unfinished_set; // per var
     int_vector              m_dfs_time;       // per var
-    dl_var_vector           m_roots;     
+    dl_var_vector           m_roots;
     dl_var_vector           m_unfinished;
     int                     m_next_dfs_time;
     int                     m_next_scc_id;
@@ -260,10 +262,10 @@ class dl_graph {
         return true;
     }
 
-    
+
     bool is_feasible(const edge & e) const {
-        return 
-            !e.is_enabled() || 
+        return
+            !e.is_enabled() ||
             m_assignment[e.get_target()] - m_assignment[e.get_source()] <= e.get_weight();
     }
 
@@ -296,6 +298,9 @@ public:
 
     numeral const& get_weight(edge_id id) const { return m_edges[id].get_weight(); }
 
+    edge_id_vector const& get_out_edges(dl_var v) const { return m_out_edges[v]; }
+
+    edge_id_vector const& get_in_edges(dl_var v) const { return m_in_edges[v]; }
 
 private:
     // An assignment is almost feasible if all but edge with idt edge are feasible.
@@ -325,7 +330,7 @@ private:
     }
 
     // Store in gamma the normalized weight. The normalized weight is given
-    // by the formula  
+    // by the formula
     // m_assignment[e.get_source()] - m_assignment[e.get_target()] + e.get_weight()
     void set_gamma(const edge & e, numeral & gamma) {
         gamma  = m_assignment[e.get_source()];
@@ -350,10 +355,10 @@ private:
         }
         return true;
     }
-    
+
     // Make the assignment feasible. An assignment is feasible if
     // Forall edge e. m_assignment[e.get_target()] - m_assignment[e.get_source()] <= e.get_weight()
-    // 
+    //
     // This method assumes that if the assignment is not feasible, then the only infeasible edge
     // is the last added edge.
     bool make_feasible(edge_id id) {
@@ -388,7 +393,7 @@ private:
                 undo_assignments();
                 return false;
             }
-            
+
             typename edge_id_vector::iterator it  = m_out_edges[source].begin();
             typename edge_id_vector::iterator end = m_out_edges[source].end();
             for (; it != end; ++it) {
@@ -399,7 +404,7 @@ private:
                     continue;
                 }
                 set_gamma(e, gamma);
-                
+
                 if (gamma.is_neg()) {
                     target   = e.get_target();
                     switch (m_mark[target]) {
@@ -447,7 +452,7 @@ private:
         for (; it != end; ++it) {
             edge_id e_id = *it;
             edge const& e2 = m_edges[e_id];
-            if (e2.get_target() == dst && 
+            if (e2.get_target() == dst &&
                 e2.is_enabled() && // or at least not be inconsistent with current choices
                 e2.get_weight() > w && (e2.get_weight() - w + gamma).is_neg()) {
                 e = &e2;
@@ -460,7 +465,7 @@ private:
     }
 
 public:
-    
+
     dl_graph():
         m_heap(1024, dl_var_lt<Ext>(m_gamma)),
         m_timestamp(0),
@@ -511,6 +516,9 @@ public:
         TRACE("dl_bug", tout << "creating edge:\n"; display_edge(tout, m_edges.back()););
         m_out_edges[source].push_back(new_id);
         m_in_edges[target].push_back(new_id);
+
+        m_freq_astar.push_back(0);
+
         return new_id;
     }
 
@@ -528,7 +536,7 @@ public:
                 r = make_feasible(id);
             }
             SASSERT(check_invariant());
-            SASSERT(!r || is_feasible()); 
+            SASSERT(!r || is_feasible());
             m_enabled_edges.push_back(id);
         }
         return r;
@@ -561,7 +569,7 @@ public:
 
 
     //
-    // Here is a version that tries to 
+    // Here is a version that tries to
     // Find shortcuts on the cycle.
     // A shortcut is an edge that that is subsumed
     // by the current edges, but provides for a shorter
@@ -569,7 +577,7 @@ public:
     // Example (<= (- a b) k1) (<= (- b c) k2) (<= (- c d) k3)
     // An edge (<= (- a d) k4) where k1 + k2 + k3 <= k4, but gamma + k4 - (k1+k2+k3) < 0
     // is still a conflict.
-    // 
+    //
     template<typename Functor>
     void traverse_neg_cycle2(bool try_relax, Functor & f) {
         static unsigned num_conflicts = 0;
@@ -591,16 +599,16 @@ public:
             const edge & e = m_edges[e_id];
             dl_var src = e.get_source();
             potential += e.get_weight();
-                        
+
             //
             // search for edges that can reduce size of negative cycle.
             //
             typename edge_id_vector::iterator it = m_out_edges[src].begin();
-            typename edge_id_vector::iterator end = m_out_edges[src].end();            
+            typename edge_id_vector::iterator end = m_out_edges[src].end();
             for (; it != end; ++it) {
                 edge_id e_id2 = *it;
                 edge const& e2 = m_edges[e_id2];
-                dl_var src2 = e2.get_target();                
+                dl_var src2 = e2.get_target();
                 if (e_id2 == e_id || !e2.is_enabled()) {
                     continue;
                 }
@@ -622,7 +630,7 @@ public:
                         nodes.shrink(j + 1);
                         potentials.shrink(j + 1);
                         edges.shrink(j + 1);
-                        edges.push_back(e_id2);           
+                        edges.push_back(e_id2);
                         potential = potentials[j] + weight;
                         break;
                     }
@@ -634,12 +642,12 @@ public:
             potentials.push_back(potential);
             nodes.push_back(src);
             e_id = m_parent[src];
-                  
+
             SASSERT(check_path(potentials, nodes, edges));
         }
         while (e_id != last_id);
-        
-        TRACE("diff_logic_traverse", {   
+
+        TRACE("diff_logic_traverse", {
                 tout << "Num conflicts: " << num_conflicts << "\n";
                 tout << "Resulting path:\n";
                 for (unsigned i = 0; i < edges.size(); ++i) {
@@ -651,7 +659,7 @@ public:
         if (!check_explanation(edges.size(), edges.c_ptr())) {
             throw default_exception("edges are not inconsistent");
         }
-       
+
         // allow theory to introduce shortcut lemmas.
         prune_edges(edges, f);
 
@@ -661,10 +669,10 @@ public:
         }
     }
 
-    // 
+    //
     // Create fresh literals obtained by resolving a pair (or more)
     // literals associated with the edges.
-    // 
+    //
 
     template<typename Functor>
     void prune_edges(svector<edge_id>& edges, Functor & f) {
@@ -691,12 +699,12 @@ public:
             if (m_activity[e_id] < min_activity) {
                 min_activity = m_activity[e_id];
                 idx = i;
-            }                
+            }
         }
-        
+
         dl_var dst = get_source(edges[idx+1]);
         dl_var src = get_target(edges[idx]);
-        
+
         f.new_edge(src, dst, 2, edges.begin()+idx);
     }
 
@@ -725,12 +733,12 @@ public:
                 max_idx = i;
             }
         }
-        
+
         //
         // e1 e2 i1 e4 e5 e6 .. e8 i2 e9 e10
         // =>
         // e1 e2 e_new d9 e10
-        // 
+        //
         // alternative:
         // e_new e4 ... e8 is the new edge.
         //
@@ -738,13 +746,13 @@ public:
         //
         if (idx2 < idx1) {
             std::swap(idx1,idx2);
-        }        
-        (void) max_idx;
+        }
+        // (void) max_idx;
         SASSERT(idx1 < idx2 && idx2 < edges.size());
         SASSERT(max_idx < edges.size());
         dst = get_source(edges[idx2]);
         src = get_target(edges[idx1]);
-        
+
         f.new_edge(src, dst, idx2-idx1+1, edges.begin()+idx1);
     }
 
@@ -754,7 +762,7 @@ public:
         // SASSERT(is_feasible()); <<< I relaxed this condition
         m_trail_stack.push_back(scope(m_edges.size(), m_enabled_edges.size(), m_timestamp));
     }
-    
+
     // Backtrack num_scopes scopes.
     // Restore the previous number of edges.
     void pop(unsigned num_scopes) {
@@ -784,7 +792,7 @@ public:
             m_edges.pop_back();
         }
         m_trail_stack.shrink(new_lvl);
-        SASSERT(check_invariant()); 
+        SASSERT(check_invariant());
         // SASSERT(is_feasible()); <<< I relaxed the condition in push(), so this assertion is not valid anymore.
     }
 
@@ -838,7 +846,7 @@ public:
 
     void inc_assignment(dl_var v, numeral const& inc) {
         m_assignment[v] += inc;
-    }    
+    }
 
 
     struct every_var_proc {
@@ -863,7 +871,7 @@ public:
             }
         }
         out << "digraph "" {\n";
-        
+
         unsigned n = m_assignment.size();
         for (unsigned v = 0; v < n; v++) {
             if (vars.contains(v)) {
@@ -956,8 +964,8 @@ public:
     }
 
     void get_neighbours_undirected(dl_var current, svector<dl_var> & neighbours) {
-	    neighbours.reset();
-	    edge_id_vector & out_edges = m_out_edges[current];
+            neighbours.reset();
+            edge_id_vector & out_edges = m_out_edges[current];
         typename edge_id_vector::iterator it = out_edges.begin(), end = out_edges.end();
         for (; it != end; ++it) {
             edge_id e_id = *it;
@@ -968,7 +976,7 @@ public:
         }
         edge_id_vector & in_edges = m_in_edges[current];
         typename edge_id_vector::iterator it2 = in_edges.begin(), end2 = in_edges.end();
-	    for (; it2 != end2; ++it2) {
+            for (; it2 != end2; ++it2) {
             edge_id e_id = *it2;
             edge & e     = m_edges[e_id];
             SASSERT(e.get_target() == current);
@@ -980,73 +988,105 @@ public:
     void dfs_undirected(dl_var start, svector<dl_var> & threads) {
         threads.reset();
         threads.resize(get_num_nodes());
-	    uint_set discovered, explored;
-	    svector<dl_var> nodes;
+            uint_set discovered, explored;
+            svector<dl_var> nodes;
         discovered.insert(start);
-	    nodes.push_back(start);
-	    dl_var prev = start;
-	    while(!nodes.empty()) {
-		    dl_var current = nodes.back();
+            nodes.push_back(start);
+            dl_var prev = start;
+            while(!nodes.empty()) {
+                    dl_var current = nodes.back();
             SASSERT(discovered.contains(current) && !explored.contains(current));
-		    svector<dl_var> neighbours;
-		    get_neighbours_undirected(current, neighbours);
+                    svector<dl_var> neighbours;
+                    get_neighbours_undirected(current, neighbours);
             SASSERT(!neighbours.empty());
             bool found = false;
-		    for (unsigned i = 0; i < neighbours.size(); ++i) {
+                    for (unsigned i = 0; i < neighbours.size(); ++i) {
                 dl_var next = neighbours[i];
                 DEBUG_CODE(
                 edge_id id;
-                SASSERT(get_edge_id(current, next, id) || get_edge_id(next, current, id)););                
+                SASSERT(get_edge_id(current, next, id) || get_edge_id(next, current, id)););
                 if (!discovered.contains(next) && !explored.contains(next)) {
                     TRACE("diff_logic", tout << "thread[" << prev << "] --> " << next << std::endl;);
                     threads[prev] = next;
                     prev = next;
                     discovered.insert(next);
-	                nodes.push_back(next);
+                        nodes.push_back(next);
                     found = true;
                     break;
                 }
-		    }            
+                    }
             SASSERT(!nodes.empty());
             if (!found) {
                 explored.insert(current);
                 nodes.pop_back();
             }
-	    }
-	    threads[prev] = start;
+            }
+            threads[prev] = start;
     }
 
-    void bfs_undirected(dl_var start, svector<dl_var> & parents, svector<dl_var> & depths) {
+    bool can_reach(dl_var src, dl_var dst) {
+        uint_set target, visited;
+        target.insert(dst);
+        return reachable(src, target, visited, dst);
+    }
+
+    bool reachable(dl_var start, uint_set const& target, uint_set& visited, dl_var& dst) {
+        visited.reset();
+        svector<dl_var> nodes;
+        nodes.push_back(start);
+        for (unsigned i = 0; i < nodes.size(); ++i) {
+            dl_var n = nodes[i];
+            if (visited.contains(n)) continue;
+            visited.insert(n);
+            edge_id_vector & edges = m_out_edges[n];
+            typename edge_id_vector::iterator it  = edges.begin();
+            typename edge_id_vector::iterator end = edges.end();
+            for (; it != end; ++it) {
+                edge_id e_id = *it;
+                edge & e     = m_edges[e_id];
+                if (e.is_enabled()) {
+                    dst = e.get_target();
+                    if (target.contains(dst)) {
+                        return true;
+                    }
+                    nodes.push_back(dst);
+                }
+            }
+        }
+        return false;
+    }
+
+    void bfs_undirected(dl_var start, svector<dl_var> & parents, svector<unsigned> & depths) {
         parents.reset();
         parents.resize(get_num_nodes());
         parents[start] = -1;
         depths.reset();
         depths.resize(get_num_nodes());
-	    uint_set visited;
-	    std::deque<dl_var> nodes;
-	    visited.insert(start);
-	    nodes.push_front(start);
-	    while(!nodes.empty()) {
+            uint_set visited;
+            std::deque<dl_var> nodes;
+            visited.insert(start);
+            nodes.push_front(start);
+            while(!nodes.empty()) {
             dl_var current = nodes.back();
             nodes.pop_back();
-		    SASSERT(visited.contains(current));
+                    SASSERT(visited.contains(current));
             svector<dl_var> neighbours;
-		    get_neighbours_undirected(current, neighbours);
+                    get_neighbours_undirected(current, neighbours);
             SASSERT(!neighbours.empty());
-		    for (unsigned i = 0; i < neighbours.size(); ++i) {
-			    dl_var next = neighbours[i];
+                    for (unsigned i = 0; i < neighbours.size(); ++i) {
+                            dl_var next = neighbours[i];
                 DEBUG_CODE(
                 edge_id id;
                 SASSERT(get_edge_id(current, next, id) || get_edge_id(next, current, id)););
                 if (!visited.contains(next)) {
                     TRACE("diff_logic", tout << "parents[" << next << "] --> " << current << std::endl;);
-	                parents[next] = current;
-	                depths[next] = depths[current] + 1;
-	                visited.insert(next);
-	                nodes.push_front(next);
+                        parents[next] = current;
+                        depths[next] = depths[current] + 1;
+                        visited.insert(next);
+                        nodes.push_front(next);
                 }
-		    }
-	    }
+              }
+            }
     }
 
     template<typename Functor>
@@ -1096,13 +1136,13 @@ public:
         for (dl_var v = 0; v < n; v++) {
             if (m_dfs_time[v] == -1) {
                 dfs(v, scc_id);
-            }        
+            }
         }
         TRACE("eq_scc",
               for (dl_var v = 0; v < n; v++) {
                   tout << "$" << v << " -> " << scc_id[v] << "\n";
               });
-    }    
+    }
 
     void dfs(dl_var v, int_vector & scc_id) {
         m_dfs_time[v] = m_next_dfs_time;
@@ -1191,11 +1231,11 @@ public:
     }
 
     numeral get_assignment(dl_var v) const {
-        return m_assignment[v]; 
+        return m_assignment[v];
     }
 
     void set_assignment(dl_var v, numeral const & n) {
-        m_assignment[v] = n; 
+        m_assignment[v] = n;
     }
 
     unsigned get_timestamp() const {
@@ -1231,16 +1271,16 @@ private:
         // Debug:
         numeral potential0;
         for (unsigned i = 0; i < edges.size(); ++i) {
-            
+
             potential0 += m_edges[edges[i]].get_weight();
-            if (potential0 != potentials[i] || 
+            if (potential0 != potentials[i] ||
                 nodes[i] != m_edges[edges[i]].get_source()) {
                 TRACE("diff_logic_traverse", tout << "checking index " << i << " ";
                       tout << "potential: " << potentials[i] << " ";
                       display_edge(tout, m_edges[edges[i]]);
                       );
                 return false;
-            }                
+            }
         }
         return true;
     }
@@ -1253,7 +1293,7 @@ private:
             e_id = m_parent[m_edges[e_id].get_source()];
         }
         while (e_id != last_id);
-        
+
         return gamma2 == m_gamma[m_edges[last_id].get_source()];
     }
 
@@ -1263,10 +1303,12 @@ private:
         dl_var       m_var;
         int          m_parent_idx;
         edge_id      m_edge_id;
-        bfs_elem(dl_var v, int parent_idx, edge_id e):
+//        int          m_path_cost;
+        bfs_elem(dl_var v, int parent_idx, edge_id e/*, int path_cost = 0*/):
             m_var(v),
             m_parent_idx(parent_idx),
-            m_edge_id(e) {
+            m_edge_id(e)/*,
+            m_path_cost(path_cost)*/{
         }
     };
 
@@ -1276,16 +1318,26 @@ public:
     // Return true if the path exists, false otherwise.
     template<typename Functor>
     bool find_shortest_zero_edge_path(dl_var source, dl_var target, unsigned timestamp, Functor & f) {
+      return find_shortest_path_aux(source, target, timestamp, f, true);
+    }
+    template<typename Functor>
+    bool find_shortest_reachable_path(dl_var source, dl_var target, unsigned timestamp, Functor & f) {
+      return find_shortest_path_aux(source, target, timestamp, f, false);
+    }
+
+    template<typename Functor>
+    bool find_shortest_path_aux(dl_var source, dl_var target, unsigned timestamp, Functor & f, bool zero_edge) {
         svector<bfs_elem> bfs_todo;
         svector<char>     bfs_mark;
         bfs_mark.resize(m_assignment.size(), false);
-        
+
         bfs_todo.push_back(bfs_elem(source, -1, null_edge_id));
         bfs_mark[source] = true;
-        
+
         unsigned  m_head = 0;
         numeral gamma;
         while (m_head < bfs_todo.size()) {
+            m_total_count++;
             bfs_elem & curr = bfs_todo[m_head];
             int parent_idx  = m_head;
             m_head++;
@@ -1303,9 +1355,9 @@ public:
                 }
                 set_gamma(e, gamma);
                 TRACE("dl_bfs", tout << "processing edge: "; display_edge(tout, e); tout << "gamma: " << gamma << "\n";);
-                if (gamma.is_zero() && e.get_timestamp() < timestamp) {
+                if ((gamma.is_zero() || (!zero_edge && gamma.is_neg())) && e.get_timestamp() < timestamp) {
                     dl_var curr_target = e.get_target();
-                    TRACE("dl_bfs", tout << "curr_target: " << curr_target << 
+                    TRACE("dl_bfs", tout << "curr_target: " << curr_target <<
                           ", mark: " << static_cast<int>(bfs_mark[curr_target]) << "\n";);
                     if (curr_target == target) {
                         TRACE("dl_bfs", tout << "found path\n";);
@@ -1350,31 +1402,299 @@ public:
             }
         }
         return false;
-    } 
+    }
+
+    template<typename Functor>
+    bool find_path(dl_var source, dl_var target, unsigned timestamp, Functor & f) {
+        auto zero_edge = true;
+//        svector<bfs_elem> bfs_todo;
+
+        std::queue<int> bfs_todo;
+        std::vector<int> dfs_todo;
+
+//        struct Compare {
+//            bool operator()(const bfs_elem& a, const bfs_elem& b) {
+//                return a.m_path_cost < b.m_path_cost;
+//            }
+//        };
 
+//        std::priority_queue<bfs_elem, std::vector<bfs_elem>, Compare> bfs_todo;
+
+        svector<char>     bfs_mark;
+        bfs_mark.resize(m_assignment.size(), false);
+
+        svector<int>     parent;
+        parent.resize(m_assignment.size(), false);
+
+        bfs_todo.push(source);
+//        bfs_todo_no_pop.push_back(bfs_elem(source, -1, null_edge_id));
+        parent[source] = -1;
+        bfs_mark[source] = true;
+
+//        unsigned  m_head = 0;
+        numeral gamma;
+        while (!bfs_todo.empty() || !dfs_todo.empty()) {
+            m_total_count++;
+
+            dl_var v;
+            if (!dfs_todo.empty()) {
+                v = dfs_todo.back();
+                dfs_todo.pop_back();
+            } else {
+                v = bfs_todo.front();
+                bfs_todo.pop();
+            }
+
+            //int parent_idx  = m_head;
+//            m_head++;
+//            int parent_idx = parent[v];
+            TRACE("dl_bfs", tout << "processing: " << v << "\n";);
+            edge_id_vector & edges = m_out_edges[v];
+            typename edge_id_vector::iterator it  = edges.begin();
+            typename edge_id_vector::iterator end = edges.end();
+            for (; it != end; ++it) {
+                edge_id e_id = *it;
+                edge & e     = m_edges[e_id];
+                SASSERT(e.get_source() == v);
+                if (!e.is_enabled()) {
+                    continue;
+                }
+                set_gamma(e, gamma);
+                TRACE("dl_bfs", tout << "processing edge: "; display_edge(tout, e); tout << "gamma: " << gamma << "\n";);
+                if ((gamma.is_zero() || (!zero_edge && gamma.is_neg())) && e.get_timestamp() < timestamp) {
+                    dl_var curr_target = e.get_target();
+                    TRACE("dl_bfs", tout << "curr_target: " << curr_target <<
+                          ", mark: " << static_cast<int>(bfs_mark[curr_target]) << "\n";);
+                    if (curr_target == target) {
+//                        TRACE("dl_bfs", tout << "found path\n";);
+//                        TRACE("dl_eq_bug", tout << "path: " << source << " --> " << target << "\n";
+//                              display_edge(tout, e);
+//                              int tmp_parent_idx = parent_idx;
+//                              for (;;) {
+//                                  bfs_elem & curr = bfs_todo_no_pop[tmp_parent_idx];
+//                                  if (curr.m_edge_id == null_edge_id) {
+//                                      break;
+//                                  }
+//                                  else {
+//                                      edge & e = m_edges[curr.m_edge_id];
+//                                      display_edge(tout, e);
+//                                      tmp_parent_idx = curr.m_parent_idx;
+//                                  }
+//                                  tout.flush();
+//                              });
+//                        TRACE("dl_eq_bug", display_edge(tout, e););
+                        f(e.get_explanation());
+                        m_freq_astar[e_id]++;
+                        for (;;) {
+                            int p = parent[v];
+                            if (p == -1)
+                                return true;
+
+                            edge_id eid;
+                            bool ret = get_edge_id(p, v, eid);
+
+                            if (eid == null_edge_id || !ret) {
+                                return true;
+                            }
+                            else {
+                                edge & e = m_edges[eid];
+                                TRACE("dl_eq_bug", display_edge(tout, e););
+                                f(e.get_explanation());
+                                m_freq_astar[eid]++;
+                                v = p;
+                            }
+                        }
+                    }
+                    else {
+                        if (!bfs_mark[curr_target]) {
+                            if (m_freq_astar[e_id] > 1) {
+//                                std::cerr << "HERE\n";
+                                dfs_todo.push_back(curr_target);
+                            } else {
+                                bfs_todo.push(curr_target);
+                            }
+                            bfs_mark[curr_target] = true;
+                            parent[curr_target] = v;
+                        }
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+
+    std::vector<int> m_freq_astar;
+    int m_total_count = 0;
+
+//    template<typename Functor>
+//    bool find_path(dl_var source, dl_var target, unsigned timestamp, Functor & f) {
+////        struct RAII{
+////            RAII() {std::cerr << "START\n";}
+////            ~RAII() {std::cerr << "END\n";}
+////        };
+////        RAII r;
+
+//        auto zero_edge = true;
+////        svector<bfs_elem> bfs_todo;
+////        svector<char>     bfs_mark;
+////        bfs_mark.resize(m_assignment.size(), false);
+//        svector<char> visited(m_assignment.size(), false);
+//        svector<dl_var> parent(m_assignment.size(), -1);
+//        svector<int> path_cost(m_assignment.size(), 0);
+//        svector<int> state(m_assignment.size(), 0);
+
+//        struct Comparator {
+//            bool operator()(dl_var a, dl_var b) {
+////                    std::cout << "COMP "
+////                                    << a << ':' << state->data()[a] << ' ' << b << ':' << state->data()[b] << std::endl;
+//                return state->get(a) > state->get(b);
+//            }
+//            svector<int>* state;
+//        };
+
+//        Comparator comp{&state};
+//        std::priority_queue<dl_var, std::vector<dl_var>, Comparator> queue(comp);
+
+//        queue.push(source);
+
+//        parent[source] = source;
+
+////        std::cerr << m_assignment.size() << std::endl;
+
+////        bfs_todo.push_back(bfs_elem(source, -1, null_edge_id));
+////        bfs_mark[source] = true;
+
+////        unsigned  m_head = 0;
+//        numeral gamma;
+////        while (m_head < bfs_todo.size()) {
+//        while (!queue.empty()) {
+//            m_total_count++;
+////            bfs_elem & curr = bfs_todo[m_head];
+//            dl_var current = queue.top();
+////            visited[current] = true;
+//            queue.pop();
+////            int parent_idx  = m_head;
+//            int parent_idx = parent[current];
+////            m_head++;
+//            dl_var  v = current;
+////            TRACE("dl_bfs", tout << "processing: " << v << "\n";);
+//            edge_id_vector & edges = m_out_edges[v];
+//            typename edge_id_vector::iterator it  = edges.begin();
+//            typename edge_id_vector::iterator end = edges.end();
+//            for (; it != end; ++it) {
+//                edge_id e_id = *it;
+//                edge & e     = m_edges[e_id];
+//                SASSERT(e.get_source() == v);
+//                if (!e.is_enabled()) {
+//                    continue;
+//                }
+//                set_gamma(e, gamma);
+////                TRACE("dl_bfs", tout << "processing edge: "; display_edge(tout, e); tout << "gamma: " << gamma << "\n";);
+//                if ((gamma.is_zero() || (!zero_edge && gamma.is_neg())) && e.get_timestamp() < timestamp) {
+//                    dl_var curr_target = e.get_target();
+////                    TRACE("dl_bfs", tout << "curr_target: " << curr_target <<
+////                          ", mark: " << static_cast<int>(bfs_mark[curr_target]) << "\n";);
+
+//                    parent[curr_target] = current;
+
+//                    if (curr_target == target) {
+////                        TRACE("dl_bfs", tout << "found path\n";);
+////                        TRACE("dl_eq_bug", tout << "path: " << source << " --> " << target << "\n";
+////                              display_edge(tout, e);
+////                              int tmp_parent_idx = parent_idx;
+////                              for (;;) {
+////                                  bfs_elem & curr = bfs_todo[tmp_parent_idx];
+////                                  if (curr.m_edge_id == null_edge_id) {
+////                                      break;
+////                                  }
+////                                  else {
+////                                      edge & e = m_edges[curr.m_edge_id];
+////                                      display_edge(tout, e);
+////                                      tmp_parent_idx = curr.m_parent_idx;
+////                                  }
+////                                  tout.flush();
+////                              });
+////                        TRACE("dl_eq_bug", display_edge(tout, e););
+
+//                        f(e.get_explanation());
+//                        m_freq_astar[e_id]++;
+//                        for (;;) {
+//                            SASSERT(parent_idx >= 0);
+
+////                            bfs_elem & curr = bfs_todo[parent_idx];
+//                            int curr = parent_idx;
+
+//                            edge_id eid;
+//                            auto ret = get_edge_id(curr, v, eid);
+//                            if (!ret)
+//                                return true;
+////                            SASSERT(ret);
+
+//                            m_freq_astar[eid]++;
+
+//                            if (eid == null_edge_id) {
+//                                return true;
+//                            }
+//                            else {
+//                                edge & e = m_edges[eid];
+////                                TRACE("dl_eq_bug", display_edge(tout, e););
+//                                f(e.get_explanation());
+//                                parent_idx = parent[curr];
+//                                if (parent_idx == curr)
+//                                    return true;
+//                            }
+//                        }
+
+////                        int path = target;
+////                        int old;
+////                        do {
+////                                old = path;
+////                                path = parent[path];
+////                                std::cerr << "P " << old << std::endl;
+////                        } while (old != source);
+
+//                    }
+//                    else {
+////                        if (!bfs_mark[curr_target]) {
+////                            bfs_todo.push_back(bfs_elem(curr_target, parent_idx, e_id));
+////                            bfs_mark[curr_target] = true;
+////                        }
+//                        if (!visited[curr_target]) {
+//                            path_cost[curr_target] = path_cost[current] + 1;
+//                            state[curr_target] = path_cost[curr_target] /*- m_freq_astar[e_id]*/;
+//                            queue.push(curr_target);
+//                            visited[curr_target] = true;
+//                        }
+//                    }
+//                }
+//            }
+//        }
+//        return false;
+//    }
 
     //
     // Theory propagation:
     // Given a (newly) added edge id, find the ids of un-asserted edges that
     // that are subsumed by the id.
     // Separately, reproduce explanations for those ids.
-    // 
+    //
     // The algorithm works in the following way:
     // 1. Let e = source -- weight --> target be the edge at id.
     // 2. Compute successors (over the assigned edges) of source,
     //    those traversing source-target and those leaving source over different edges.
     //    compute forward potential of visited nodes.
     //    queue up nodes that are visited, and require the source->target edge.
-    // 3. Compute pre-decessors (over the assigned edges) of target, 
+    // 3. Compute pre-decessors (over the assigned edges) of target,
     //    those traversing source-target, and those entering target
     //    without visiting source. Maintain only nodes that enter target
     //    compute backward potential of visited nodes.
     //    Queue up nodes that are visited, and require the source->target edge.
     // 4. traverse the smaller of the two lists.
-    //    check if there is an edge between the two sets such that 
-    //    the weight of the edge is >= than the sum of the two potentials - weight 
+    //    check if there is an edge between the two sets such that
+    //    the weight of the edge is >= than the sum of the two potentials - weight
     //    (since 'weight' is added twice in the traversal.
-    // 
+    //
 private:
     struct dfs_state {
         class hp_lt {
@@ -1386,7 +1706,7 @@ private:
                 numeral const& delta1 = m_delta[v1];
                 numeral const& delta2 = m_delta[v2];
                 return delta1 < delta2 ||
-                    (delta1 == delta2 && 
+                    (delta1 == delta2 &&
                      m_mark[v1] == DL_PROP_IRRELEVANT && m_mark[v2] == DL_PROP_RELEVANT);
             }
         };
@@ -1409,7 +1729,7 @@ private:
         void add_size(unsigned n) { m_num_edges += n; }
         unsigned get_size() const { return m_num_edges; }
 
-        bool contains(dl_var v) const { 
+        bool contains(dl_var v) const {
             // TBD can be done better using custom marking.
             for (unsigned i = 0; i < m_visited.size(); ++i) {
                 if (v == m_visited[i]) {
@@ -1458,9 +1778,9 @@ private:
         state.m_heap.insert(target);
         unsigned num_relevant = 1;
         TRACE("diff_logic", display(tout); );
-                
+
         while (!state.m_heap.empty() && num_relevant > 0) {
-                      
+
             ++m_stats.m_implied_literal_cost;
 
             source = state.m_heap.erase_min();
@@ -1476,7 +1796,7 @@ private:
                 m_mark[source] = DL_PROP_PROCESSED_IRRELEVANT;
             }
             TRACE("diff_logic", tout << "source: " << source << "\n";);
-  
+
             typename edge_id_vector::const_iterator it  = edges[source].begin();
             typename edge_id_vector::const_iterator end = edges[source].end();
 
@@ -1496,7 +1816,7 @@ private:
                 target = is_fw?e.get_target():e.get_source();
                 delta  = get_reduced_weight(state, source, e);
                 SASSERT(delta >= state.m_delta[source]);
-                
+
                 target_mark = static_cast<dl_prop_search_mark>(m_mark[target]);
                 switch(target_mark) {
                 case DL_PROP_UNMARKED: {
@@ -1512,8 +1832,8 @@ private:
                 case DL_PROP_RELEVANT:
                 case DL_PROP_IRRELEVANT: {
                     numeral const& old_delta = state.m_delta[target];
-                    if (delta < old_delta || 
-                        (delta == old_delta && 
+                    if (delta < old_delta ||
+                        (delta == old_delta &&
                          source_mark == DL_PROP_IRRELEVANT && target_mark == DL_PROP_RELEVANT)) {
                         state.m_delta[target] = delta;
                         m_mark[target]  = source_mark;
@@ -1528,12 +1848,12 @@ private:
                     }
                     break;
                 }
-                case DL_PROP_PROCESSED_RELEVANT: 
+                case DL_PROP_PROCESSED_RELEVANT:
                     TRACE("diff_logic", tout << delta << " ?> " << state.m_delta[target] << "\n";);
                     SASSERT(delta >= state.m_delta[target]);
                     SASSERT(!(delta == state.m_delta[target] && source_mark == DL_PROP_IRRELEVANT));
                     break;
-                case DL_PROP_PROCESSED_IRRELEVANT: 
+                case DL_PROP_PROCESSED_IRRELEVANT:
                     TRACE("diff_logic", tout << delta << " ?> " << state.m_delta[target] << "\n";);
                     SASSERT(delta >= state.m_delta[target]);
                     break;
@@ -1541,8 +1861,8 @@ private:
                     UNREACHABLE();
                 }
             }
-        }        
-        
+        }
+
         //
         // Clear marks using m_visited and m_heap.
         //
@@ -1585,7 +1905,7 @@ private:
         dl_var b = e0.get_target();
         numeral n0 = m_assignment[b] - m_assignment[a] - e0.get_weight();
         vector<edge_id_vector> const& edges = m_out_edges;
-        TRACE("diff_logic", tout << "$" << a << " a:" << m_assignment[a] << " $" << b << " b: " << m_assignment[b] 
+        TRACE("diff_logic", tout << "$" << a << " a:" << m_assignment[a] << " $" << b << " b: " << m_assignment[b]
               << " e0: " << e0.get_weight() << " n0: " << n0 << "\n";
               display_edge(tout, e0);
               );
@@ -1606,9 +1926,9 @@ private:
                 numeral n2 = n1 + tgt.m_delta[d] + m_assignment[d];
 
                 if (tgt.contains(d) && n2 <= e1.get_weight()) {
-                    TRACE("diff_logic", 
+                    TRACE("diff_logic",
                           tout << "$" << c << " delta_c: " << src.m_delta[c] << " c: " << m_assignment[c] << "\n";
-                          tout << "$" << d << " delta_d: " << src.m_delta[d] << " d: " << m_assignment[d] 
+                          tout << "$" << d << " delta_d: " << src.m_delta[d] << " d: " << m_assignment[d]
                           << " n2: " << n2 << " e1: " << e1.get_weight() << "\n";
                           display_edge(tout << "found: ", e1););
                     ++m_stats.m_num_implied_literals;
@@ -1621,13 +1941,13 @@ private:
 public:
     void find_subsumed(edge_id id, svector<edge_id>& subsumed) {
         fix_sizes();
-        find_relevant<true>(m_fw, id);        
+        find_relevant<true>(m_fw, id);
         find_relevant<false>(m_bw, id);
         find_subsumed(id, m_bw, m_fw, subsumed);
         m_fw.m_visited.reset();
         m_bw.m_visited.reset();
         if (!subsumed.empty()) {
-            TRACE("diff_logic", 
+            TRACE("diff_logic",
                   display(tout);
                   tout << "subsumed\n";
                   for (unsigned i = 0; i < subsumed.size(); ++i) {
@@ -1676,11 +1996,11 @@ public:
     // Find edges that are subsumed by id, or is an edge between
     // a predecessor of id's source and id's destination, or
     // is an edge between a successor of id's dst, and id's source.
-    // 
+    //
     //        src - id -> dst
-    //     -                 - 
+    //     -                 -
     //  src'                  dst'
-    // 
+    //
     // so searching for:
     // . src - id' -> dst
     // . src' - id' -> dst
@@ -1744,13 +2064,13 @@ public:
                     ++m_stats.m_num_implied_literals;
                 }
             }
-        }        
+        }
     }
 
     template<class Functor>
     void explain_subsumed_lazy(edge_id bridge_id, edge_id subsumed_id, Functor& f) {
         edge const& e1 = m_edges[bridge_id];
-        edge const& e2 = m_edges[subsumed_id];        
+        edge const& e2 = m_edges[subsumed_id];
         dl_var src2 = e2.get_source();
         dl_var dst2 = e2.get_target();
         unsigned timestamp = e1.get_timestamp();
@@ -1760,11 +2080,11 @@ public:
         // timestamp, and of length no longer than weight of e2.
         //
         // use basic O(m*n) algorithm that traverses each edge once per node.
-        // 
+        //
 
         ++m_stats.m_num_helpful_implied_literals;
-        
-        SASSERT(m_heap.empty());       
+
+        SASSERT(m_heap.empty());
         SASSERT(e1.is_enabled());
 
         m_gamma[src2].reset();
@@ -1772,11 +2092,11 @@ public:
         m_heap.insert(src2);
         m_visited.push_back(src2);
 
-        TRACE("diff_logic", 
-              display_edge(tout << "bridge:   ", e1); 
-              display_edge(tout << "subsumed: ", e2); 
+        TRACE("diff_logic",
+              display_edge(tout << "bridge:   ", e1);
+              display_edge(tout << "subsumed: ", e2);
               display(tout); );
-        
+
         while (true) {
             SASSERT(!m_heap.empty());
             dl_var v = m_heap.erase_min();
@@ -1803,7 +2123,7 @@ public:
                 if (w == dst2 && gamma <= e2.get_weight()) {
                     // found path.
                     reset_marks();
-                    m_heap.reset();              
+                    m_heap.reset();
                     unsigned length = 0;
                     do {
                         inc_activity(m_parent[w]);
diff --git a/src/smt/smt_context.cpp b/src/smt/smt_context.cpp
index 0c32f3c7..cecd7c95 100644
--- a/src/smt/smt_context.cpp
+++ b/src/smt/smt_context.cpp
@@ -4370,6 +4370,15 @@ namespace smt {
         return m_last_search_failure; 
     }
 
+  //BEGIN: ASHU
+  void context::collect_asserted_linear_constr( ast_ref_vector& atoms ) {
+    m_model_generator->collect_asserted_linear_constr( atoms );
+  }
+  void context::collect_asserted_po_constr( ast_ref_vector& atoms ) {
+    m_model_generator->collect_asserted_po_constr( atoms );
+  }
+  //END: ASHU
+
     void context::add_rec_funs_to_model() {
         ast_manager& m = m_manager;
         SASSERT(m_model);
diff --git a/src/smt/smt_context.h b/src/smt/smt_context.h
index 9c70f599..c4d7db15 100644
--- a/src/smt/smt_context.h
+++ b/src/smt/smt_context.h
@@ -1568,6 +1568,11 @@ namespace smt {
         func_decl * get_macro_interpretation(unsigned i, expr_ref & interp) const { return m_asserted_formulas.get_macro_interpretation(i, interp); }
         quantifier * get_macro_quantifier(func_decl * f) const { return m_asserted_formulas.get_macro_quantifier(f); }
         void insert_macro(func_decl * f, quantifier * m, proof * pr) { m_asserted_formulas.insert_macro(f, m, pr); }
+
+      //BEGIN: ASHU
+      void collect_asserted_linear_constr( ast_ref_vector& );
+      void collect_asserted_po_constr( ast_ref_vector& );
+      //END: ASHU
     };
 
 };
diff --git a/src/smt/smt_kernel.cpp b/src/smt/smt_kernel.cpp
index 9bdf962e..ddce9f29 100644
--- a/src/smt/smt_kernel.cpp
+++ b/src/smt/smt_kernel.cpp
@@ -379,4 +379,13 @@ namespace smt {
         return m_imp->m_kernel;
     }
 
+  //BEGIN: ASHU
+  void kernel::collect_asserted_linear_constr( ast_ref_vector& atoms ) {
+    m_imp->m_kernel.collect_asserted_linear_constr( atoms );
+  }
+  void kernel::collect_asserted_po_constr( ast_ref_vector& atoms ) {
+    m_imp->m_kernel.collect_asserted_po_constr( atoms );
+  }
+  //END: ASHU
+
 };
diff --git a/src/smt/smt_kernel.h b/src/smt/smt_kernel.h
index 264fae01..35c06af0 100644
--- a/src/smt/smt_kernel.h
+++ b/src/smt/smt_kernel.h
@@ -258,6 +258,10 @@ namespace smt {
            \warning We should not use this method
         */
         context & get_context();
+      //BEGIN: ASHU
+      void collect_asserted_linear_constr( ast_ref_vector& );
+      void collect_asserted_po_constr( ast_ref_vector& );
+      //END: ASHU
     };
 };
 
diff --git a/src/smt/smt_model_generator.cpp b/src/smt/smt_model_generator.cpp
index b9c1ac45..ed0ba937 100644
--- a/src/smt/smt_model_generator.cpp
+++ b/src/smt/smt_model_generator.cpp
@@ -33,7 +33,14 @@ namespace smt {
         m_context(0),
         m_fresh_idx(1),
         m_asts(m_manager),
-        m_model(0) {
+        m_model(0),
+        //BEGIN: ASHU
+        f1s(m_manager),
+        f2s(m_manager),
+        added_constr(m_manager),
+        assigned_atoms(m_manager)
+        //END: ASHU
+    {
     }
 
     model_generator::~model_generator() {
@@ -312,20 +319,24 @@ namespace smt {
               svector<source>::const_iterator it  = sources.begin();
               svector<source>::const_iterator end = sources.end();
               for (; it != end; ++it) {
-                  source const & curr = *it;
-                  if (curr.is_fresh_value()) {
-                      tout << "fresh!" << curr.get_value()->get_idx() << " " << mk_pp(curr.get_value()->get_sort(), m_manager) << "\n";
-                  }
-                  else {
-                      enode * n = curr.get_enode();
-                      SASSERT(n->get_root() == n);
-                      sort * s = m_manager.get_sort(n->get_owner());
-                      tout << "#" << n->get_owner_id() << " " << mk_pp(s, m_manager);
-                      model_value_proc * proc = 0;
-                      root2proc.find(n, proc);
-                      SASSERT(proc);
-                      tout << " is_fresh: " << proc->is_fresh() << "\n";
-                  }
+                //ASHU: changed printing
+                source const & curr = *it;
+                if ( curr.is_fresh_value() ) {
+                  tout << "fresh!" << curr.get_value()->get_idx() << " "
+                       << mk_pp(curr.get_value()->get_sort(), m_manager)
+                       << "\n";
+                } else {
+                  enode * n = curr.get_enode();
+                  SASSERT(n->get_root() == n);
+                  sort * s = m_manager.get_sort(n->get_owner());
+                  tout << "#" << n->get_owner_id() << ":= ";
+                  ast_ll_bounded_pp( tout, m_manager, n->get_owner(), 1);
+                  tout << ":" << mk_pp( s, m_manager );
+                  model_value_proc * proc = 0;
+                  root2proc.find(n, proc);
+                  SASSERT(proc);
+                  tout << " is_fresh: " << proc->is_fresh() << "\n";
+                }
               });
         svector<source>::const_iterator it  = sources.begin();
         svector<source>::const_iterator end = sources.end();
@@ -531,5 +542,5 @@ namespace smt {
         register_macros();
         return m_model;
     }
-    
+
 };
diff --git a/src/smt/smt_model_generator.h b/src/smt/smt_model_generator.h
index f360dbd7..5136d777 100644
--- a/src/smt/smt_model_generator.h
+++ b/src/smt/smt_model_generator.h
@@ -32,6 +32,9 @@ Revision History:
 #include"smt_types.h"
 #include"obj_hashtable.h"
 #include"map.h"
+//BEGIN: ASHU
+#include "func_interp.h"
+//END: ASHU
 
 class value_factory;
 class proto_model;
@@ -182,7 +185,15 @@ namespace smt {
         obj_map<enode, app *>         m_root2value;
         ast_ref_vector                m_asts;
         proto_model *                 m_model;
-        obj_hashtable<func_decl>      m_hidden_ufs;
+
+      //BEGIN: ASHU
+      func_decl_ref_vector f1s;
+      func_decl_ref_vector f2s;
+      expr_ref_vector added_constr;
+      expr_ref_vector assigned_atoms;
+      //END: ASHU
+
+      obj_hashtable<func_decl>      m_hidden_ufs;
 
         void init_model();
         void mk_bool_model();
@@ -220,6 +231,12 @@ namespace smt {
         proto_model * mk_model();
 
         obj_map<enode, app *> const & get_root2value() const { return m_root2value; }
+
+      //BEGIN: ASHU
+      void collect_asserted_linear_constr( ast_ref_vector& );
+      void collect_asserted_po_constr( ast_ref_vector& );
+      app* search_matching_term( func_decl*, func_entry const*);
+      //END: ASHU
         app * get_value(enode * n) const;
 
         void hide(func_decl * f) { 
diff --git a/src/smt/smt_setup.cpp b/src/smt/smt_setup.cpp
index 4dd1e251..7c0b12a9 100644
--- a/src/smt/smt_setup.cpp
+++ b/src/smt/smt_setup.cpp
@@ -34,6 +34,7 @@ Revision History:
 #include"theory_seq.h"
 #include"theory_pb.h"
 #include"theory_fpa.h"
+#include"theory_special_relations.h"
 #include"theory_str.h"
 
 namespace smt {
@@ -865,6 +866,11 @@ namespace smt {
         m_context.register_plugin(alloc(theory_fpa, m_manager));
     }
 
+
+    void setup::setup_special_relations() {
+        m_context.register_plugin(alloc(theory_special_relations, m_manager));
+    }
+
     void setup::setup_str() {
         setup_arith();
         m_context.register_plugin(alloc(theory_str, m_manager, m_params));
@@ -886,6 +892,7 @@ namespace smt {
         setup_seq_str(st);
         setup_card();
         setup_fpa();
+        setup_special_relations();
     }
 
     void setup::setup_unknown(static_features & st) {
diff --git a/src/smt/smt_setup.h b/src/smt/smt_setup.h
index f12cc5e0..a0f41448 100644
--- a/src/smt/smt_setup.h
+++ b/src/smt/smt_setup.h
@@ -102,8 +102,8 @@ namespace smt {
         void setup_mi_arith();
         void setup_r_arith();
         void setup_fpa();
+        void setup_special_relations();
         void setup_str();
-
     public:
         setup(context & c, smt_params & params);
         void mark_already_configured() { m_already_configured = true; }
diff --git a/src/smt/smt_solver.cpp b/src/smt/smt_solver.cpp
index cd912b72..aa8f2b55 100644
--- a/src/smt/smt_solver.cpp
+++ b/src/smt/smt_solver.cpp
@@ -27,6 +27,11 @@ Notes:
 #include"func_decl_dependencies.h"
 #include"dec_ref_util.h"
 
+//BEGIN: ASHU
+extern ast_ref_vector* asserted_linear_constr_vector;
+extern ast_ref_vector* asserted_po_constr_vector;
+//END: ASHU
+
 namespace smt {
 
     class solver : public solver_na2as {
@@ -141,7 +146,18 @@ namespace smt {
 
         virtual lbool check_sat_core(unsigned num_assumptions, expr * const * assumptions) {
             TRACE("solver_na2as", tout << "smt_solver::check_sat_core: " << num_assumptions << "\n";);
-            return m_context.check(num_assumptions, assumptions);
+            //BEGIN: ASHU
+            lbool res = m_context.check(num_assumptions, assumptions);
+            if (asserted_linear_constr_vector) {
+              asserted_linear_constr_vector->reset();
+              m_context.collect_asserted_linear_constr(*asserted_linear_constr_vector);
+            }
+            if (asserted_po_constr_vector) {
+              asserted_po_constr_vector->reset();
+              m_context.collect_asserted_po_constr(*asserted_po_constr_vector);
+            }
+            return res;
+            //END: ASHU
         }
 
         struct scoped_minimize_core {
diff --git a/src/smt/tactic/smt_tactic.cpp b/src/smt/tactic/smt_tactic.cpp
index 9e3eddaf..ec47f76c 100644
--- a/src/smt/tactic/smt_tactic.cpp
+++ b/src/smt/tactic/smt_tactic.cpp
@@ -30,6 +30,11 @@ Notes:
 #include"solver.h"
 #include"mus.h"
 
+//BEGIN: ASHU
+extern ast_ref_vector* asserted_linear_constr_vector;
+extern ast_ref_vector* asserted_po_constr_vector;
+//END: ASHU
+
 typedef obj_map<expr, expr *> expr2expr_map;
 
 
@@ -137,6 +142,16 @@ public:
         ~scoped_init_ctx() {
             smt::kernel * d = m_owner.m_ctx;
             m_owner.m_ctx = 0;
+            //BEGIN: ASHU
+            if( asserted_linear_constr_vector ) {
+              asserted_linear_constr_vector->reset();
+              d->collect_asserted_linear_constr(*asserted_linear_constr_vector);
+            }
+            if( asserted_po_constr_vector ) {
+              asserted_po_constr_vector->reset();
+              d->collect_asserted_po_constr(*asserted_po_constr_vector);
+            }
+            //END: ASHU
 
             if (d)
                 dealloc(d);
diff --git a/src/smt/theory_arith.h b/src/smt/theory_arith.h
index cdc1a393..1d46fa2a 100644
--- a/src/smt/theory_arith.h
+++ b/src/smt/theory_arith.h
@@ -1105,6 +1105,21 @@ namespace smt {
     public:
         virtual void collect_statistics(::statistics & st) const;
         virtual void display(std::ostream & out) const;
+
+  //BEGIN: ASHU
+      void collect_asserted_atoms( vector< std::pair<bool_var,bool> >& atoms) const {
+        for (unsigned i = 0; i < m_asserted_qhead; i++) {
+            bound * b = m_asserted_bounds[i];
+            if (b->is_atom()) {
+              atom* a = static_cast<atom*>(b);
+              bool_var bv = a->get_bool_var();
+              bool istr = a->is_true();
+              atoms.push_back( std::make_pair(bv,istr) );
+            }
+        }
+    }
+  //END: ASHU
+
     protected:
         void display_row(std::ostream & out, unsigned r_id, bool compact = true) const;
         void display_row(std::ostream & out, row const & r, bool compact = true) const;
